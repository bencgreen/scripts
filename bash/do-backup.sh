#!/bin/bash

# THE MIT LICENSE (MIT)
#
# Copyright © 2020 bcg|design
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the “Software”), to deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit
# persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
# Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
# OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


# ======================================================================================================================
#
# DO NOT EDIT THIS FILE
# CONFIGURATION IS DONE USING backup-config.sh
#
# ======================================================================================================================

VERSION=0.2.2006141437


# ======================================================================================================================
# UTILS
# ======================================================================================================================

SCRIPT_DIR=$(dirname $0)
UTILS="$SCRIPT_DIR/utils.sh"
if [ ! -f "$UTILS" ]; then
  echo "Please create $UTILS before running this script"
  exit
fi

source "$UTILS"


# ======================================================================================================================
# CONFIG
# ======================================================================================================================

CONFIG="$SCRIPT_DIR/backup-config.sh"
if [ ! -f "$CONFIG" ]; then
  echo "Please create $CONFIG before running this script"
  exit
fi

source "$CONFIG"


# ======================================================================================================================
# VARIABLES
# ======================================================================================================================

START=`date +%s`
TODAY="$(date +%Y%m%d)"
NOW="$(date +%H%M)"
LOG="$LOG_DIR/backup-$TODAY.log"


# ======================================================================================================================
# START
# ======================================================================================================================

printf "\nStarting new backup (backup script version $VERSION)\n" >> "$LOG"
mkdir -p "$LOG_DIR"


# ======================================================================================================================
# FUNCTIONS - BACKUP
# ======================================================================================================================

# perform backup using rsync
#   1: file or directory to backup
#   2: directory to backup into
backup_rsync() {

  if [ -z "$RSYNC_EXCLUSIONS" ] || [ ! -f "$RSYNC_EXCLUSIONS" ]; then
    RESULTS=$(rsync -$RSYNC_ARGS --delete --force "$1" "$2")
  else
    RESULTS=$(rsync -$RSYNC_ARGS --exclude-from="$RSYNC_EXCLUSIONS" --delete "$1" "$2")
  fi

}

# perform backup using rclone
# progress will be sent to stdout, everything else logged to the log file directly
#   1: file or directory to backup
#   2: directory to backup into
backup_rclone() {

  printf "\n" 2>&1 | tee -a "$LOG";

  RCLONE_VERSION=$(rclone version | grep -Po -m1 "(\d+\.)+\d+")
  RCLONE_USER_AGENT="ISV|rclone.org|rclone/v$RCLONE_VERSION"

  if [ -z "$RCLONE_EXCLUSIONS" ] || [ ! -f "$RCLONE_EXCLUSIONS" ]; then
    rclone sync -$RCLONE_ARGS --config="$RCLONE_CONFIG" --log-file="$LOG" --user-agent "$RCLONE_USER_AGENT" --tpslimit $RCLONE_TPS_LIMIT "$1" "$2"
  else
    # if this is the first rclone with exclusions, dump the filters
    if [ "$RCLONE_COUNT" -eq "0" ]; then
      rclone sync -$RCLONE_ARGS --config="$RCLONE_CONFIG" --log-file="$LOG" --user-agent "$RCLONE_USER_AGENT" --tpslimit $RCLONE_TPS_LIMIT --exclude-from "$RCLONE_EXCLUSIONS" --dump filters "$1" "$2"
      ((RCLONE_COUNT=RCLONE_COUNT+1))
    else
      rclone sync -$RCLONE_ARGS --config="$RCLONE_CONFIG" --log-file="$LOG" --user-agent "$RCLONE_USER_AGENT" --tpslimit $RCLONE_TPS_LIMIT --exclude-from "$RCLONE_EXCLUSIONS" "$1" "$2"
    fi
  fi

}

RCLONE_COUNT=0

# perform backup
#   1: file or directory to backup
#   2: (optional) directory to backup into - default is $BACKUP_DIR
backup () {

  # first argument is required
  if [[ -z "$1" ]]; then
    echo "You must pass a file or directory to backup"
    exit
  fi

  # use default backup dir if not set
  BACKUP_DIR_TMP="$BACKUP_DIR"
  [[ -n "$2" ]] && BACKUP_DIR_TMP="$2"

  # ensure backup directory exists
  mkdir -p "$BACKUP_DIR_TMP"

  # do backup
  e "Backing up $1 to $BACKUP_DIR_TMP"

  # use specified method
  case $METHOD in
    "rsync") backup_rsync "$1" "$BACKUP_DIR_TMP";;
    "rclone") backup_rclone "$1" "$BACKUP_DIR_TMP";;
    *) p "Unknown backup method '$METHOD'.";;
  esac

  # output changes with two-space indent
  p "$RESULTS"

  # done
  echo_done

}

# loop through backup array
#   1: associative array of directories / files to backup
backup_loop () {

  # get array
  local -n A=$1

  # loop
  for key in "${!A[@]}"; do
    backup "$key" "${A[$key]}"
  done

}


# ======================================================================================================================
# FUNCTIONS - COMPRESS
# ======================================================================================================================

# compress backup files
compress () {

  if [ ! -z "$COMPRESS_DIR" ]; then

    e "Compressing $BACKUP_DIR to $COMPRESS_DIR"

    # create subdirectory for today
    COMPRESS_DIR_TODAY="$COMPRESS_DIR/$TODAY"
    mkdir -p "$COMPRESS_DIR_TODAY"

    # compress file path
    COMPRESS_FILE="$COMPRESS_DIR_TODAY/$TODAY-$NOW.tar.gz"

    # do compression
    # need to remove '/'' prefix from BACKUP_DIR to avoid tar warning 'Removing leading `/' from member names'
    RESULTS=$(tar cfz - -C / "${BACKUP_DIR#*/}" | split -b $COMPRESS_MAX_FILE_SIZE - "$COMPRESS_FILE")
    p "$RESULTS"

    # done
    echo_done

  fi

}


# ======================================================================================================================
# BACKUP DIRECTORIES & FILES
# ======================================================================================================================

backup_loop D
backup_loop F


# ======================================================================================================================
# COMPRESS
# ======================================================================================================================

compress


# ======================================================================================================================
# DELETE OLD FILES
# ======================================================================================================================

delete_old_files "log" $KEEP_LOGS_FOR "$LOG_DIR"

if [ ! -z "$COMPRESS_DIR" ]; then
  delete_old_files "compressed backup" $KEEP_COMPRESSED_FOR "$COMPRESS_DIR"
fi


# ======================================================================================================================
# COMPLETE
# ======================================================================================================================

END=`date +%s`

((H=($END - $START) / 3600))
((M=(($END - $START) % 3600) / 60))
((S=($END - $START) % 60))
printf "Backup completed in %02dh %02dm %02ds\n" $H $M $S 2>&1 | tee -a "$LOG"
